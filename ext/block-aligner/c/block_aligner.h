#ifndef block_aligner_h
#define block_aligner_h

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#define ALIGNED(n) __attribute__ ((aligned(n)))

/**
 * A match/mismatch, insertion, or deletion operation.
 *
 * When aligning `q` against `r`, this represents the edit operations to get from `r` to `q`.
 */
enum Operation
#ifdef __cplusplus
  : uint8_t
#endif // __cplusplus
 {
  /**
   * Placeholder variant.
   */
  Sentinel = 0,
  /**
   * Match or mismatch.
   *
   * This is a diagonal transition in the DP matrix with `|q| + 1` rows and `|r| + 1` columns.
   */
  M = 1,
  /**
   * Match.
   */
  Eq = 2,
  /**
   * Mismatch.
   */
  X = 3,
  /**
   * Insertion.
   *
   * When aligning sequences `q` against `r`, this is a gap in `r`.
   * This is a row transition in the DP matrix with `|q| + 1` rows and `|r| + 1` columns.
   */
  I = 4,
  /**
   * Deletion.
   *
   * When aligning sequences `q` against `r`, this is a gap in `q`.
   * This is a column transition in the DP matrix with `|q| + 1` rows and `|r| + 1` columns.
   */
  D = 5,
};
#ifndef __cplusplus
typedef uint8_t Operation;
#endif // __cplusplus

/**
 * Amino acid scoring matrix.
 *
 * Supports characters `A` to `Z`. Lowercase characters are uppercased.
 */
typedef struct AAMatrix AAMatrix;

/**
 * Amino acid position specific scoring matrix.
 *
 * Supports characters `A` to `Z`. Lowercase characters are uppercased.
 */
typedef struct AAProfile AAProfile;

/**
 * A CIGAR string that holds a list of operations.
 */
typedef struct Cigar Cigar;

/**
 * Nucleotide scoring matrix.
 *
 * Supports characters `A`, `C`, `G`, `N`, and `T`. Lowercase characters are uppercased.
 *
 * If a larger alphabet is needed (for example, with IUPAC characters), use `AAMatrix` instead.
 */
typedef struct NucMatrix NucMatrix;

/**
 * A padded string that helps avoid out of bounds access when using SIMD.
 *
 * A single padding byte in inserted before the start of the string,
 * and `block_size` bytes are inserted after the end of the string.
 */
typedef struct PaddedBytes PaddedBytes;

/**
 * An operation and how many times that operation is repeated.
 */
typedef struct OpLen {
  Operation op;
  uintptr_t len;
} OpLen;

/**
 * A handle for a block in block aligner.
 */
typedef void *BlockHandle;

/**
 * Open and extend gap costs.
 *
 * Open cost must include the extend cost. For example, with `Gaps { open: -11, extend: -1 }`,
 * a gap of length 1 costs -11, and a gap of length 2 costs -12.
 */
typedef struct Gaps {
  int8_t open;
  int8_t extend;
} Gaps;

/**
 * Represents a range that has inclusive lower and upper bounds.
 */
typedef struct SizeRange {
  uintptr_t min;
  uintptr_t max;
} SizeRange;

/**
 * Resulting score and alignment end position.
 */
typedef struct AlignResult {
  int32_t score;
  uintptr_t query_idx;
  uintptr_t reference_idx;
} AlignResult;

/**
 * Arbitrary bytes scoring matrix.
 */
typedef struct ByteMatrix {
  int8_t match_score;
  int8_t mismatch_score;
} ByteMatrix;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Match = 1, mismatch = -1.
 */
extern const struct NucMatrix NW1;

extern const struct AAMatrix BLOSUM45;

extern const struct AAMatrix BLOSUM50;

extern const struct AAMatrix BLOSUM62;

extern const struct AAMatrix BLOSUM80;

extern const struct AAMatrix BLOSUM90;

extern const struct AAMatrix PAM100;

extern const struct AAMatrix PAM120;

extern const struct AAMatrix PAM160;

extern const struct AAMatrix PAM200;

extern const struct AAMatrix PAM250;

/**
 * Match = 1, mismatch = -1.
 */
extern const struct ByteMatrix BYTES1;

/**
 * Create a new simple AAMatrix with custom match and mismatch scores.
 *
 * Note that the match score must be positive and the mismatch score must be negative.
 */
struct AAMatrix *block_new_simple_aamatrix(int8_t match_score, int8_t mismatch_score);

/**
 * Set an entry in the AAMatrix.
 */
void block_set_aamatrix(struct AAMatrix *matrix, uint8_t a, uint8_t b, int8_t score);

/**
 * Frees an AAMatrix.
 */
void block_free_aamatrix(struct AAMatrix *matrix);

/**
 * Create a new profile of a specific length, with default (large negative) values.
 *
 * Note that internally, the created profile is longer than a conventional position-specific scoring
 * matrix (and `str_len`) by 1, so the profile will have the same length as the number of
 * columns in the DP matrix.
 * The first column of scores in the profile should be large negative values (padding).
 * This allows gap open costs to be specified for the first column of the DP matrix.
 */
struct AAProfile *block_new_aaprofile(uintptr_t str_len, uintptr_t block_size, int8_t gap_extend);

/**
 * Get the length of the profile.
 */
uintptr_t block_len_aaprofile(const struct AAProfile *profile);

/**
 * Clear the profile so it can be reused for profile lengths less than or equal
 * to the length this struct was created with.
 */
void block_clear_aaprofile(struct AAProfile *profile, uintptr_t str_len, uintptr_t block_size);

/**
 * Set the score for a position and byte.
 *
 * The profile should be first `clear`ed before it is reused with different lengths.
 *
 * The first column (`i = 0`) should be padded with large negative values.
 * Therefore, set values starting from `i = 1`.
 */
void block_set_aaprofile(struct AAProfile *profile, uintptr_t i, uint8_t b, int8_t score);

/**
 * Set the scores for all positions in the position specific scoring matrix.
 *
 * The profile should be first `clear`ed before it is reused with different lengths.
 *
 * Use `order` to specify the order of bytes that is used in the `scores` matrix.
 * Scores (in `scores`) should be stored in row-major order, where each row is a different position
 * and each column is a different byte.
 */
void block_set_all_aaprofile(struct AAProfile *profile,
                             const uint8_t *order,
                             uintptr_t order_len,
                             const int8_t *scores,
                             uintptr_t scores_len,
                             uintptr_t left_shift,
                             uintptr_t right_shift);

/**
 * Set the scores for all positions in reverse in the position specific scoring matrix.
 *
 * The profile should be first `clear`ed before it is reused with different lengths.
 *
 * Use `order` to specify the order of bytes that is used in the `scores` matrix.
 * Scores (in `scores`) should be stored in row-major order, where each row is a different position
 * and each column is a different byte.
 */
void block_set_all_rev_aaprofile(struct AAProfile *profile,
                                 const uint8_t *order,
                                 uintptr_t order_len,
                                 const int8_t *scores,
                                 uintptr_t scores_len,
                                 uintptr_t left_shift,
                                 uintptr_t right_shift);

/**
 * Set the gap open cost for a column.
 *
 * When aligning a sequence `q` to a profile `r`, this is the gap open cost at column `i` for a
 * column transition in the DP matrix with `|q| + 1` rows and `|r| + 1` columns.
 * This represents starting a gap in `q`.
 */
void block_set_gap_open_C_aaprofile(struct AAProfile *profile, uintptr_t i, int8_t gap);

/**
 * Set the gap close cost for a column.
 *
 * When aligning a sequence `q` to a profile `r`, this is the gap close cost at column `i` for
 * ending column transitions in the DP matrix with `|q| + 1` rows and `|r| + 1` columns.
 * This represents ending a gap in `q`.
 */
void block_set_gap_close_C_aaprofile(struct AAProfile *profile, uintptr_t i, int8_t gap);

/**
 * Set the gap open cost for a row.
 *
 * When aligning a sequence `q` to a profile `r`, this is the gap open cost at column `i` for
 * a row transition in the DP matrix with `|q| + 1` rows and `|r| + 1` columns.
 * This represents starting a gap in `r`.
 */
void block_set_gap_open_R_aaprofile(struct AAProfile *profile, uintptr_t i, int8_t gap);

/**
 * Set the gap open cost for all column transitions.
 */
void block_set_all_gap_open_C_aaprofile(struct AAProfile *profile, int8_t gap);

/**
 * Set the gap close cost for all column transitions.
 */
void block_set_all_gap_close_C_aaprofile(struct AAProfile *profile, int8_t gap);

/**
 * Set the gap open cost for all row transitions.
 */
void block_set_all_gap_open_R_aaprofile(struct AAProfile *profile, int8_t gap);

/**
 * Get the score for a position and byte.
 */
int8_t block_get_aaprofile(const struct AAProfile *profile, uintptr_t i, uint8_t b);

/**
 * Get the gap extend cost.
 */
int8_t block_get_gap_extend_aaprofile(const struct AAProfile *profile);

/**
 * Frees an AAProfile.
 */
void block_free_aaprofile(struct AAProfile *profile);

/**
 * Create a new empty CIGAR string.
 */
struct Cigar *block_new_cigar(uintptr_t query_len, uintptr_t reference_len);

/**
 * Get the operation at a certain index in a CIGAR string.
 */
struct OpLen block_get_cigar(const struct Cigar *cigar, uintptr_t i);

/**
 * Get the length of a CIGAR string.
 */
uintptr_t block_len_cigar(const struct Cigar *cigar);

/**
 * Frees a CIGAR string.
 */
void block_free_cigar(struct Cigar *cigar);

/**
 * Create a new empty padded amino acid string.
 */
struct PaddedBytes *block_new_padded_aa(uintptr_t len, uintptr_t max_size);

/**
 * Write to a padded amino acid string.
 */
void block_set_bytes_padded_aa(struct PaddedBytes *padded,
                               const uint8_t *s,
                               uintptr_t len,
                               uintptr_t max_size);

/**
 * Write to a padded amino acid string, in reverse.
 */
void block_set_bytes_rev_padded_aa(struct PaddedBytes *padded,
                                   const uint8_t *s,
                                   uintptr_t len,
                                   uintptr_t max_size);

/**
 * Frees a padded amino acid string.
 */
void block_free_padded_aa(struct PaddedBytes *padded);

/**
 *Create a new block aligner instance for global alignment of amino acid strings (no traceback).
 */
BlockHandle block_new_aa(uintptr_t query_len, uintptr_t reference_len, uintptr_t max_size);

/**
 *Global alignment of two amino acid strings (no traceback).
 */
void block_align_aa(BlockHandle b,
                    const struct PaddedBytes *q,
                    const struct PaddedBytes *r,
                    const struct AAMatrix *m,
                    struct Gaps g,
                    struct SizeRange s,
                    int32_t x);

/**
 *Global alignment of an amino acid sequence to a profile (no traceback).
 */
void block_align_profile_aa(BlockHandle b,
                            const struct PaddedBytes *q,
                            const struct AAProfile *r,
                            struct SizeRange s,
                            int32_t x);

/**
 *Retrieves the result of global alignment of two amino acid strings (no traceback).
 */
struct AlignResult block_res_aa(BlockHandle b);

/**
 *Don't use.
 */
void _block_cigar_aa(BlockHandle b,
                     uintptr_t query_idx,
                     uintptr_t reference_idx,
                     struct Cigar *cigar);

/**
 *Don't use.
 */
void _block_cigar_eq_aa(BlockHandle b,
                        const struct PaddedBytes *q,
                        const struct PaddedBytes *r,
                        uintptr_t query_idx,
                        uintptr_t reference_idx,
                        struct Cigar *cigar);

/**
 *Frees the block used for global alignment of two amino acid strings (no traceback).
 */
void block_free_aa(BlockHandle b);

/**
 *Create a new block aligner instance for X-drop alignment of amino acid strings (no traceback).
 */
BlockHandle block_new_aa_xdrop(uintptr_t query_len, uintptr_t reference_len, uintptr_t max_size);

/**
 *X-drop alignment of two amino acid strings (no traceback).
 */
void block_align_aa_xdrop(BlockHandle b,
                          const struct PaddedBytes *q,
                          const struct PaddedBytes *r,
                          const struct AAMatrix *m,
                          struct Gaps g,
                          struct SizeRange s,
                          int32_t x);

/**
 *X-drop alignment of an amino acid sequence to a profile (no traceback).
 */
void block_align_profile_aa_xdrop(BlockHandle b,
                                  const struct PaddedBytes *q,
                                  const struct AAProfile *r,
                                  struct SizeRange s,
                                  int32_t x);

/**
 *Retrieves the result of X-drop alignment of two amino acid strings (no traceback).
 */
struct AlignResult block_res_aa_xdrop(BlockHandle b);

/**
 *Don't use.
 */
void _block_cigar_aa_xdrop(BlockHandle b,
                           uintptr_t query_idx,
                           uintptr_t reference_idx,
                           struct Cigar *cigar);

/**
 *Don't use.
 */
void _block_cigar_eq_aa_xdrop(BlockHandle b,
                              const struct PaddedBytes *q,
                              const struct PaddedBytes *r,
                              uintptr_t query_idx,
                              uintptr_t reference_idx,
                              struct Cigar *cigar);

/**
 *Frees the block used for X-drop alignment of two amino acid strings (no traceback).
 */
void block_free_aa_xdrop(BlockHandle b);

/**
 *Create a new block aligner instance for global alignment of amino acid strings, with traceback.
 */
BlockHandle block_new_aa_trace(uintptr_t query_len, uintptr_t reference_len, uintptr_t max_size);

/**
 *Global alignment of two amino acid strings, with traceback.
 */
void block_align_aa_trace(BlockHandle b,
                          const struct PaddedBytes *q,
                          const struct PaddedBytes *r,
                          const struct AAMatrix *m,
                          struct Gaps g,
                          struct SizeRange s,
                          int32_t x);

/**
 *Global alignment of an amino acid sequence to a profile, with traceback.
 */
void block_align_profile_aa_trace(BlockHandle b,
                                  const struct PaddedBytes *q,
                                  const struct AAProfile *r,
                                  struct SizeRange s,
                                  int32_t x);

/**
 *Retrieves the result of global alignment of two amino acid strings, with traceback.
 */
struct AlignResult block_res_aa_trace(BlockHandle b);

/**
 *Retrieves the resulting CIGAR string from global alignment of two amino acid strings, with traceback.
 */
void block_cigar_aa_trace(BlockHandle b,
                          uintptr_t query_idx,
                          uintptr_t reference_idx,
                          struct Cigar *cigar);

/**
 *Retrieves the resulting CIGAR string from global alignment of two amino acid strings, with traceback containing =/X.
 */
void block_cigar_eq_aa_trace(BlockHandle b,
                             const struct PaddedBytes *q,
                             const struct PaddedBytes *r,
                             uintptr_t query_idx,
                             uintptr_t reference_idx,
                             struct Cigar *cigar);

/**
 *Frees the block used for global alignment of two amino acid strings, with traceback.
 */
void block_free_aa_trace(BlockHandle b);

/**
 *Create a new block aligner instance for X-drop alignment of amino acid strings, with traceback.
 */
BlockHandle block_new_aa_trace_xdrop(uintptr_t query_len,
                                     uintptr_t reference_len,
                                     uintptr_t max_size);

/**
 *X-drop alignment of two amino acid strings, with traceback.
 */
void block_align_aa_trace_xdrop(BlockHandle b,
                                const struct PaddedBytes *q,
                                const struct PaddedBytes *r,
                                const struct AAMatrix *m,
                                struct Gaps g,
                                struct SizeRange s,
                                int32_t x);

/**
 *X-drop alignment of an amino acid sequence to a profile, with traceback.
 */
void block_align_profile_aa_trace_xdrop(BlockHandle b,
                                        const struct PaddedBytes *q,
                                        const struct AAProfile *r,
                                        struct SizeRange s,
                                        int32_t x);

/**
 *Retrieves the result of X-drop alignment of two amino acid strings, with traceback.
 */
struct AlignResult block_res_aa_trace_xdrop(BlockHandle b);

/**
 *Retrieves the resulting CIGAR string from X-drop alignment of two amino acid strings, with traceback.
 */
void block_cigar_aa_trace_xdrop(BlockHandle b,
                                uintptr_t query_idx,
                                uintptr_t reference_idx,
                                struct Cigar *cigar);

/**
 *Retrieves the resulting CIGAR string from X-drop alignment of two amino acid strings, with traceback containing =/X.
 */
void block_cigar_eq_aa_trace_xdrop(BlockHandle b,
                                   const struct PaddedBytes *q,
                                   const struct PaddedBytes *r,
                                   uintptr_t query_idx,
                                   uintptr_t reference_idx,
                                   struct Cigar *cigar);

/**
 *Frees the block used for X-drop alignment of two amino acid strings, with traceback.
 */
void block_free_aa_trace_xdrop(BlockHandle b);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* block_aligner_h */
